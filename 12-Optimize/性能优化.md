<h1>12.1 CPU vs GPU</h1>

##动画的舞台

CoreAnimation处在iOS的核心地位：应用内和应用间都能用到它。  

- 动画和屏幕上的组合的图层实际上被一个单独的进程管理，而不是你的应用程序。（这里插一句，在使用SDWebImage框架加载大量网络图片显示时，会出现程序内存警告而崩溃的情况，但是这时查看应用内存占用，会发现应用内占用内存并不高，而是整个手机的内存出现不足的情况，也就是其他内存不够用，应该是类似或者就是这种情况。）这个进程就是所谓的渲染服务。在iOS5和之前的版本是SpringBoard。在iOS6之后的版本中叫做BackBoard。
- 当运行一段动画的时候，整个过程会被四个分离的阶段打破：
  1. **布局**-这是准备你的视图、图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。
  2. **显示**-这是图层的急速图片被绘制的阶段。绘制有可能涉及你的-drawRect：和-drawLayer：inContext：方法的调用路径。
  3. **准备**-这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。
  4. **提交**-这是最后的阶段，Core Animation打包所有的图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。
- 以上这些阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有更多的工作。一旦打包的图层和动画到达渲染服务进程，他们会被反序列化成为另一个叫做渲染树的图层树。使用这个梳妆结构，渲染服务对动画的每一帧做出如下工作：
  1. 对所哟丶图层属性计算中间值，设置OpenGL几何形状来执行渲染。
  2. 在屏幕上渲染可见的三角形。

所以一共有六个阶段；最后两个阶段在动画过程中不停的重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个在GPU执行。而且你真正只能控制前两个列段：布局和显示。Core Animation框架在内部会处理剩下的事务。

##GPU相关操作

宽泛的说，大多数CALayer的属性都是GPU来绘制的。比如如果你设置图层背景或者边框颜色，那么这些可以通过着色的但搅拌实时绘制出来。如果对一个contents属性设置一张图片，然后剪裁它-它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。  
但是有一些事情会降低（基于GPU）图层绘制，比如：
  - 太多的几何结构- 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见本章后续“CPU相关操作”）。
  - 重绘-主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。
  - 离屏绘制-这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。
  - 过大的图片-如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。

##CPU相关的操作
Core Animation中CPU的大多数工作都发生在动画开始之前，这就意味着它不会影响帧率，但是他会延迟动画开始的时间，让你的界面看起来比较迟钝。  
以下CPU的操作都会延迟动画的开始时间：
  - 布局计算-如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。
  - 视图懒加载-iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会比CPU正常操作慢得多。
  - Core Graphics绘制-如果对视图实现了-drawRect:方法，或者CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。
  - 解压图片- PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。
当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树中的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU没一帧的渲染，即使这些事情不是你的应用程序可控的。
