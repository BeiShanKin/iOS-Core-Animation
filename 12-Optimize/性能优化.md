<h1>12.1 CPU vs GPU</h1>

##动画的舞台

CoreAnimation处在iOS的核心地位：应用内和应用间都能用到它。  

- 动画和屏幕上的组合的图层实际上被一个单独的进程管理，而不是你的应用程序。（这里插一句，在使用SDWebImage框架加载大量网络图片显示时，会出现程序内存警告而崩溃的情况，但是这时查看应用内存占用，会发现应用内占用内存并不高，而是整个手机的内存出现不足的情况，也就是其他内存不够用，应该是类似或者就是这种情况。）这个进程就是所谓的渲染服务。在iOS5和之前的版本是SpringBoard。在iOS6之后的版本中叫做BackBoard。
- 当运行一段动画的时候，整个过程会被四个分离的阶段打破：
  1. **布局**-这是准备你的视图、图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。
  2. **显示**-这是图层的急速图片被绘制的阶段。绘制有可能涉及你的-drawRect：和-drawLayer：inContext：方法的调用路径。
  3. **准备**-这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。
  4. **提交**-这是最后的阶段，Core Animation打包所有的图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。
- 以上这些阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有更多的工作。一旦打包的图层和动画到达渲染服务进程，他们会被反序列化成为另一个叫做渲染树的图层树。使用这个梳妆结构，渲染服务对动画的每一帧做出如下工作：
  1. 对所哟丶图层属性计算中间值，设置OpenGL几何形状来执行渲染。
  2. 在屏幕上渲染可见的三角形。

所以一共有六个阶段；最后两个阶段在动画过程中不停的重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个在GPU执行。而且你真正只能控制前两个列段：布局和显示。Core Animation框架在内部会处理剩下的事务。

##GPU相关操作

宽泛的说，大多数CALayer的属性都是GPU来绘制的。比如如果你设置图层背景或者边框颜色，那么这些可以通过着色的但搅拌实时绘制出来。如果对一个contents属性设置一张图片，然后剪裁它-它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。  
但是有一些事情会降低（基于GPU）图层绘制，比如：
  - 太多的几何结构- 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见本章后续“CPU相关操作”）。
  - 重绘-主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。
  - 离屏绘制-这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。
  - 过大的图片-如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。

